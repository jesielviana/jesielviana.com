---
title: '9 boas prÃ¡ticas para construÃ§Ã£o de API Node.js'
date: 2020-04-15T15:32:14Z
tags: ['nodejs', 'api', 'arquitetura']
draft: false
summary: 'A utilizaÃ§Ã£o de padrÃµes e boas prÃ¡ticas no desenvolvimento de software evitam a duplicidade de cÃ³digos, facilita a alteraÃ§Ã£o e evoluÃ§Ã£o do software, aumenta a legibilidade do cÃ³digo,  etc.'
images: ['/static/images/posts/banner-nodejs.png']
authors: ['default']
---

### IntroduÃ§Ã£o

[Node.js](https://nodejs.org/pt-br/) Ã© uma Ã³tima ferramenta para construÃ§Ã£o APIs REST, sendo bastante utilizada no mundo todo, desde as grandes multinacionais atÃ© startups. Assim, como qualquer framework e plataformas de desenvolvimento de software existem um conjunto de recomendaÃ§Ãµes e padrÃµes a serem utilizados, entÃ£o o objetivo deste artigo Ã© descrever um conjunto de **boas prÃ¡ticas para construÃ§Ã£o de APIs Node.js com Express**.

> A utilizaÃ§Ã£o de padrÃµes e boas prÃ¡ticas no desenvolvimento de software evitam a duplicidade de cÃ³digos, facilita a alteraÃ§Ã£o e evoluÃ§Ã£o do software, aumenta a legibilidade do cÃ³digo, etc.

O conjunto de boas prÃ¡ticas que descrevo abaixo Ã© resultado da minha experiÃªncia em construir aplicaÃ§Ãµes Node.js, de vÃ¡rios anos ensinando desenvolvimento Web, alÃ©m de uma extensa pesquisa e leitura de artigos, livros e cÃ³digos de vÃ¡rios projetos.

[o cÃ³digo completo de todos os exemplos de boas prÃ¡ticas estÃ£o neste repositÃ³rio do GitHub](https://github.com/jesielviana/nodejs-express-sequelize)

### 1 - Estrutura do projeto

Em aplicaÃ§Ãµes Node.js geralmente sÃ£o utilizados dois tipos de estruturaÃ§Ã£o de diretÃ³rios:

- divisÃ£o por funcionalidade; e
- divisÃ£o por responsabilidade

Na divisÃ£o por funcionalidade todos os arquivos de uma determinadas funcionalidade sÃ£o agrupados em um Ãºnico diretÃ³rio, conforme o exemplo abaixo:

```
src/
  â”œâ”€â”€ courses/
        â”œâ”€â”€ courses.service.js
        â”œâ”€â”€ course.model.js
        â”œâ”€â”€ courses.routes.js
  â”œâ”€â”€ students/
        â”œâ”€â”€ students.service.js
        â”œâ”€â”€ student.model.js
        â”œâ”€â”€ students.routes.js
  â”œâ”€â”€ app.js
```

JÃ¡ na organizaÃ§Ã£o por responsabilidade os arquivos sÃ£o agrupados em diretÃ³rios de acordo com a sua responsabilidade, conforme o exemplo abaixo:

```
src/
  â”œâ”€â”€ services/
        â”œâ”€â”€ courses.js
        â”œâ”€â”€ students.js
  â”œâ”€â”€ model/
        â”œâ”€â”€ course.js
        â”œâ”€â”€ student.js
  â”œâ”€â”€ routes/
        â”œâ”€â”€ index.js
        â”œâ”€â”€ courses.js
        â”œâ”€â”€ students.js
  â”œâ”€â”€ app.js
```

Entre essas duas abordagens eu prefiro a estruturaÃ§Ã£o por responsabilidade, seguindo minhas origens no mundo Java, onde essa forma de organizaÃ§Ã£o Ã© considerada o padrÃ£o. No entanto, nÃ£o acredito que seja a opÃ§Ã£o correta, fica a critÃ©rio da equipe de cada projeto discutir e escolher aquela achar mais pertinente.

Baseado na organizaÃ§Ã£o por responsabilidade, costumo organizar meus projetos da seguinte forma:

```
â”œâ”€â”€ server.js         arquivo de inicializaÃ§Ã£o da aplicaÃ§Ã£o/servidor
src/
  â”œâ”€â”€ app.js         arquivo de configuraÃ§Ã£o da aplicaÃ§Ã£o express
  â”œâ”€â”€ api/           camada de rotas da API
  â”œâ”€â”€ config/        arquivos de configuraÃ§Ã£o
  â”œâ”€â”€ services/      camada de serviÃ§os
  â”œâ”€â”€ models/        camada dos modelos	de dados
test/
  â”œâ”€â”€ unit/          testes unitÃ¡rios
  â”œâ”€â”€ integration/   testes de integraÃ§Ã£o da API
â”œâ”€â”€ package.json         arquivo de configuraÃ§Ã£o do projeto
â”œâ”€â”€ ...         demais arquivos de configuraÃ§Ãµes (.gitignore, jest.config, .sequelizerc, etc)
```

**Obs:** recomendo a criaÃ§Ã£o do arquivo `server.js` para inicializaÃ§Ã£o do servidor http separado do arquivos de definiÃ§Ã£o e configuraÃ§Ã£o do express, geralmente nomeado de `app.js` . Isso facilita demais a realizaÃ§Ã£o dos testes de integraÃ§Ã£o, pois permite testar a API usando somente o `app.js` , sem realizar chamadas de inicializaÃ§Ã£o do servidor.

### 2 - Arquitetura em Camadas

Em projetos Node.js podemos fazer a divisÃ£o em trÃªs (3) camadas, baseada no PrincÃ­pio da SeparaÃ§Ã£o de Conceitos (<a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html" target="_blank">Dijkstra</a>). As trÃªs camadas sÃ£o API/Routes, Services e Models, conforme a figura abaixo.

![Arquitetura em camada Node.js](/static/images/posts/nodejs-layers.png)

- `API/Routes` - camada responsÃ¡vel pela definiÃ§Ã£o dos _endpoints_ da _API_ e tratamento das requisiÃ§Ãµes e respostas da aplicaÃ§Ã£o.
- `Services` - camada responsÃ¡vel pelas regras de negÃ³cios e por fazer a integraÃ§Ã£o entre a camada de dados e a camada de API/Rotas.
- `Models` - camada responsÃ¡vel pela modelagem e acesso aos dados da aplicaÃ§Ã£o.

### 3 - Separe as regras de negÃ³cios do tratamento de requisiÃ§Ãµes e respostas

Ã‰ comum encontrarmos vÃ¡rias aplicaÃ§Ãµes que misturam o cÃ³digo de tratamento de requisiÃ§Ãµes e respostas com as regras de negÃ³cios da aplicaÃ§Ã£o. As vezes o cÃ³digo de regras de negÃ³cios e acesso a dados ficam juntos dentro da camada de `routes` ou `controllers`, como no exemplo abaixo (**NÃ£o FaÃ§a Isso!**):

```js:src/routes/courses.js
// arquivo de rotas
router.post('/courses', async (req, res) => {
  try {
    const { name, ch } = req.body
        const existingCourse = await courseModel.findAll({
      where: {
        name: name
      }
    })
    if (existingCourse.length > 0) {
      throw new Error('Course already registered')
    }
    await courseModel.create({ name, ch })
    res.status(201).json({ message: 'Course created!' })
  } catch (err) {
    res.status(400).send(err.message)
  }
}
```

Em outros casos os objetos de requisiÃ§Ã£o e resposta, geralmente nomeados de `req` e `res` sÃ£o passados da camada de `routes` para a camada de `services`, conforme podemos ver no exemplo abaixo (**TambÃ©m NÃ£o FaÃ§a Isso!**):

```js:src/routes/courses.js
// arquivo de tratamento de rotas na camada de routes
router.post('/courses', (req, res) => coursesService.create(req, res));
```

```js:src/services/courses.js
//  arquivo de serviÃ§os
 create(req, res) {
  try {
    const { name, ch } = req.body
        const existingCourse = await courseModel.findAll({
      where: {
        name: name
      }
    })
    if (existingCourse.length > 0) {
      throw new Error('Course already registered')
    }
    await courseModel.create({ name, ch })
    res.status(201).json({ message: 'Course created!' })
  } catch (err) {
    res.status(400).send(err.message)
  }
}
```

Nos dois exemplos acima, o cÃ³digo de tratamento de rotas, que inclui receber os dados do corpo da requisiÃ§Ã£o, capturar parÃ¢metros de URL, validar dados da requisiÃ§Ã£o, lidar com cÃ³digos de status do HTTP e retornar as respostas da requisiÃ§Ã£o estÃ£o misturados com o cÃ³digo de validaÃ§Ã£o de regras de negÃ³cios e cÃ³digo de acesso e manipulaÃ§Ã£o dos dados.

Com isso a funÃ§Ã£o/classe assume muitas responsabilidades, ferindo as boas prÃ¡ticas de coesÃ£o e separaÃ§Ã£o de conceitos. Isso impacta diretamente na escrita de testes unitÃ¡rios dos `services` em que teremos que lidar com _mocks_ complexos para os objetos `req` e `res` do express.

Diante dessa situaÃ§Ã£o, a minha recomendaÃ§Ã£o Ã© isolar o cÃ³digo de tratamento de requisiÃ§Ãµes e respostas na camada de `routes` e o cÃ³digo de regras de negÃ³cios e acesso a dados na camada de `services`. Segue um exemplo de boa prÃ¡tica baseado nos conceitos de separaÃ§Ã£o das responsabilidades e coesÃ£o:

```js
// src/routes/courses.js -> arquivo de tratamento de rotas na camada de routes
router.post('/', async (req, res) => {
  try {
    const { name, ch } = req.body
    await courseService.create({ name, ch })
    res.status(201).json({ name, ch })
  } catch (err) {
    res.status(400).send(err.message)
  }
})
```

```js:src/services/courses.js
// arquivo de serviÃ§os
async create (courseDTO) {
  try {
    await this.verifyIfCourseNameIsRegistered(courseDTO.name)
    await courseModel.create(courseDTO)
  } catch (err) {
    throw new Error(err.message)
  }
}

async verifyIfCourseNameIsRegistered (courseName) {
  const existingCourse = await courseModel.findAll({
    where: {
      name: courseName
    }
  })
  if (existingCourse.length > 0) {
    throw new Error('Course already registered')
  }
}
```

Com essa separaÃ§Ã£o mantemos as funÃ§Ãµes e arquivos/classes coesas, com responsabilidades Ãºnicas, alÃ©m disso torna a criaÃ§Ã£o dos testes unitÃ¡rios mais simples, sem a necessidade de _mock_ dos objetos de `req` e `res`.

Para todos os exemplos utilizados neste item foi utilizado um model do sequelize (listado abaixo), que representava o objeto `courseModel`.

```js:models/course.js
  const CourseModel = sequelize.define('Course', {
    name: {
      type: DataTypes.STRING,
      unique: true,
      allowNull: false,
      validate: {
        notEmpty: true
      }
    },
    ch: {
      type: DataTypes.INTEGER,
      allowNull: false,
      validate: {
        notEmpty: true
      }
    }
  })
```

> <a href="https://github.com/jesielviana/nodejs-express-sequelize" target="_blank">
>   o cÃ³digo completo de todos os exemplos de boas prÃ¡ticas estÃ£o neste repositÃ³rio do GitHub
> </a>
> .

Resumindo...

- Separe o cÃ³digo dos `routes` do express da camada de `services`
- Tudo relacionado a url, cÃ³digo de status, cabeÃ§alhos e mÃ©todos do HTTP devem ser tratados na camada/arquivo de `routes`
- NÃ£o passe os objetos `req` e `res` para a camada/arquivo de `services`
- A camada de `services` deve lidar exclusiavamente com as regras e negÃ³cios e integraÃ§Ã£o com os `models`.

### 4 - Use os mÃ©todos HTTP de forma semÃ¢ntica e substantivo para identificaÃ§Ã£o de rotas

Para cada tipo de operaÃ§Ã£o que podemos realizar por meio de uma API hÃ¡ um mÃ©todo HTTP adequado, com valor semÃ¢ntico. USE-OS! Para as quatro operaÃ§Ãµes bÃ¡sicas de um CRUD, criar, consultar, alterar e remover devemos utilizar os mÃ©todos POST, GET, PUT/PATCH e DELETE respectivamente, jÃ¡ que cada um desse mÃ©todos sÃ£o semanticamente correspondentes a cada uma dessas operaÃ§Ãµes. Por exemplo:

- `POST /courses` para criar um novo curso,
- `GET /courses` para consultar todos os cursos,
- `GET /courses/:id` para consultar um curso especÃ­fico,
- `PATCH /courses/:id` or `PUT /courses/:id` para alterar um curso jÃ¡ cadastrado,
- `DELETE /courses/:id` para remover um curso jÃ¡ cadastrado.

> OBS: PUT e PATCH sÃ£o usados para alteraÃ§Ã£o de dados. PUT Ã© semanticamente indicado para alteraÃ§Ã£o da entidade completa, ou seja, sobrescrita de todos os dados da entidade/recurso a ser alterado. JÃ¡ o PATCH para uma atualizaÃ§Ã£o parcial, quando se deseja sobrescrever um atribudo especÃ­fico da entidade/recurso
> [https://tools.ietf.org/html/rfc5789](PATCH) > [https://tools.ietf.org/html/rfc2616#section-9.6](PUT).

Como prÃ¡tica recomendada, suas rotas de API (**endpoints**) devem utilizar substantivos no plural como identificadores dos recursos, como no exemplo acima, usamos o identicador `courses` como rota (**endpoints**) para manipulaÃ§Ã£o de cursos.

### 5 - Use os cÃ³digos de status do HTTP de forma correta

Olha sÃ³ essa "pegadinha" relatada nesse tweet abaixo:

<blockquote class="twitter-tweet"><p lang="pt" dir="ltr">Submeto um formulÃ¡rio que perdi um tempo preenchendo, ele dÃ¡ um erro. Vou olhar o request (lÃ³gico), via xhr, ele dÃ¡ status 200. No json de retorno tem um atributo `{erro: true}`. ğŸ¤¦â€â™‚ï¸<br/>A empresa Ã© do mercado financeiro, e Ã© grande.<br/>NÃ£o me surpreende.<br/>Somos amadores. <a href="https://t.co/7VLEspvThv">pic.twitter.com/7VLEspvThv</a></p>&mdash; Giovanni Bassi ğŸ‡§ğŸ‡· (@giovannibassi) <a href="https://twitter.com/giovannibassi/status/1362871241128960004?ref_src=twsrc%5Etfw">February 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

O relatado no tweet acima nÃ£o Ã© algo raro, uma vez ou outra nos deparamos com isso em APIs e pÃ¡ginas Web. No entanto, Ã© algo que devemos evitar. Isso parece atÃ© uma pegadinha, retorna o status code 200, que indica sucesso na requisiÃ§Ã£o, e no corpo da resposta vem um uma mensagem de erro ou uma flag (true ou false) indicando que ocorreu algum erro...resumindo: Parece sucesso, mas Ã© erro.

Para evitar confusÃµes e mÃ¡s prÃ¡ticas retornando cÃ³digos de status do HTTP que nÃ£o condiz com a realidade da requisiÃ§Ã£o, Ã© bom conhecermos os principais cÃ³digos, seus significados e quando e como devemos usÃ¡-los. Veja a lista abaixo com os principais cÃ³digos de status do HTTP e seus significados:

- **2xx**, cÃ³digos que indicam sucesso da requisiÃ§Ã£o, os dois mais utilizados sÃ£o:
  - `200 Ok` - Indica sucesso na requisiÃ§Ã£o (pra qualquer tipo de requisiÃ§Ã£o).
  - `201 Ok` - Indica sucesso para requisiÃ§Ãµes de criaÃ§Ã£o de recurso (especÃ­fica para POST).
- **3xx**, cÃ³digos que indicam que o recurso foi movido (pouco utilizado),
- **4xx**, cÃ³digos que indicam erros causados pelo cliente
  - `400 Bad Request` â€“ indica que algum dado enviado na requisiÃ§Ã£o estÃ¡ incorreto.
  - `401 Unauthorized` â€“ indica que o usuÃ¡rio/cliente nÃ£o tem autorizaÃ§Ã£o para acessar determinado recurso, geralmente Ã© provocado pela falta de autenticaÃ§Ã£o.
  - `403 Forbidden` â€“ indica que o usuÃ¡rio Ã© conhecido (estÃ¡ autenticado), mas nÃ£o tem permissÃ£o para acessar aquele recurso.
  - `404 Not Found` â€“ indica que o recurso solicitado nÃ£o existe.
- **5xx**, indica alguma erro inesperado no lado do servidor, Ã© recomendado tratar este tipo de erro para nÃ£o ser exibido diretamente para o usuÃ¡rio/cliente.

### 6 - Crie testes de integraÃ§Ã£o para todas as rotas de sua API

Teste automatizado criado pelos desenvolvedores Ã© algum essencial no desenvolvimento de software. Esses testes sÃ£o dividos em trÃªs catagorias: Teste de Unidade, Teste de IngegraÃ§Ã£o e Teste de Inteface (end-to-end).

Para o desenvolviemtno de APIs Ã© recomendado a construÃ§Ã£o de testes de unidade e testes de integraÃ§Ã£o, sendo este o mais completo.

O teste de integraÃ§Ã£o em APIs tem caracterÃ­sticas do testes de caixa preta, que Ã© a forma de testar uma funcionalidade de um aplicativo sem o conhecimento de suas estruturas internas ou funcionamento. Portanto, na criaÃ§Ã£o dos testes de integraÃ§Ã£o o sistema/API Ã© testado como um todo sem a criaÃ§Ã£o de mocks. Nenhum mock Ã© criado!

No ambiente Node.js com Express sÃ£o bastantes utilizados o Jest e Supertest para a criaÃ§Ã£o e execuÃ§Ã£o de testes de integraÃ§Ã£o. O cÃ³digo abaixo apresenta um exemplo de teste de integraÃ§Ã£o para a criaÃ§Ã£o de curso.

```js:test/api/curso.test.js
const request = require('supertest')
const config = require('../../../src/config')
const app = require('../../../src/app')
const { sequelize } = require('../../../src/models')

const API_COURSES = `${config.API_BASE}/courses`

const DEFAULT_COURSE = {
  name: 'Curso 1',
  ch: 1500
}

beforeAll(async () => {
  await sequelize.sync({ force: true }) // conecta com o banco de testes
  await request(app).post(API_COURSES).send(DEFAULT_COURSE) // insere um curso no banco
})

afterAll(async () => {
  await sequelize.close() // fecha a conexÃ£o com o banco
})

describe('Testando a rota de curso', () => {
  test('Deve adicionar um novo curso com sucesso!', async () => {
    const newCourse = {
      name: 'Curso 2',
      ch: 3020
    }
    const response = await request(app).post(API_COURSES).send(newCourse)
    expect(response.statusCode).toBe(201)
  })
})

```

No exemplo acima Ã© realizado um teste completo de criaÃ§Ã£o de um novo curso, desde a requisiÃ§Ã£o HTTP na rota de curso passando o dados do novo curso atÃ© a inserÃ§Ã£o no banco de dados e verificaÃ§Ã£o da resposta HTTP. Exemplo completo estÃ¡ neste [repositÃ³rio do GitHub](https://github.com/jesielviana/nodejs-express-sequelize).

### 7 - Cuide bem da seguranÃ§a de sua API

Quando falamos de seguranÃ§a na Web o uso de HTTPS (TLS/SSL) Ã© fundamental e obrigatÃ³rio. USE SEMPRE HTTPS!

Quando for utilizar mÃ³dulos/depedÃªncias do NPM verifique a origem, atualizaÃ§Ãµes, possÃ­veis falhas de seguranÃ§a, etc. Para isso, recomendo a utilizaÃ§Ã£o do [Snyk Open Source Security Management](https://snyk.io/product/open-source-security-management/), uma ferramenta que conecta com seu repositÃ³rio do GitHub e verifica possÃ©veis brechas de seguranÃ§as de todas as dependÃªncias de sua aplicaÃ§Ã£o Node.js.

Em aplicaÃ§Ãµes com Express.js, use o [Helmet](https://helmetjs.github.io/). Helmet Ã© uma biblioteca para Express.js que agrega vÃ¡rios middlewares, responsÃ¡veis por setar alguns headers nas mensagens HTTP, tornando sua aplicaÃ§Ã£o mais segura.

### 8 - Crie arquivos de configuraÃ§Ã£o para cada ambiente

Crie arquivos de configuraÃ§Ãµes, com dados de banco de dados, endereÃ§os de APIs externas e etc, para cada ambiente (development, test, production) e carregue suas informaÃ§Ãµes de acordo com cada ambiente de forma automatizada. Segue um exemplo:

Arquivo index.js, que carrega as configuraÃ§Ãµes de acordo com o ambiente.

```js:config/index.js
const config = require(`./env/${process.env.NODE_ENV || 'development'}.js`)
module.exports = config
```

Arquivos de cada ambiente

```
src/
  â”œâ”€â”€ config/
      â”œâ”€â”€ development.js
      â”œâ”€â”€ test.js
      â”œâ”€â”€ production.js
```

Dentro de cada arquivo (development, test, production) sÃ£o colocadas as informaÃ§Ãµes de configuraÃ§Ã£o especÃ­ficas daquele ambiente. Pode-se usar tambÃ©m os arquivos `.env` para cada ambiente ao invÃ©s de arquivos `js` como no exemplo acima.

### 9 - Utilize IntegraÃ§Ã£o e Entrega ContÃ­nua

A IntegraÃ§Ã£o ContÃ­nua - [Continuous Integration (CI)](https://aws.amazon.com/pt/devops/continuous-integration) Ã© uma prÃ¡tica de desenvolvimento de software em que os desenvolvedores, com frequÃªncia, juntam suas alteraÃ§Ãµes de cÃ³digo em um repositÃ³rio central e executam testes automatizados.

A Entrega ContÃ­nua - [Continuous Delivery (CD)](https://www.atlassian.com/br/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment) Ã© uma extensÃ£o da integraÃ§Ã£o contÃ­nua, uma vez que implanta automaticamente todas as alteraÃ§Ãµes de cÃ³digo em um ambiente de teste e / ou produÃ§Ã£o apÃ³s o estÃ¡gio de construÃ§Ã£o.

Ã‰ importante destacar que para a utilizaÃ§Ã£o de IntegraÃ§Ã£o e Entrega ContÃ­nua Ã© essencial que sua aplicaÃ§Ã£o use e abuse de testes automatizados, testes unitÃ¡rios e principalmente testes de integraÃ§Ã£o.

A configuraÃ§Ã£o e utilizaÃ§Ã£o dos recursos de IntegraÃ§Ã£o e Entrega ContÃ­nua tem sido bastante simples em projetos armazenados no GitHub e Gitlab.
Segue um exemplo de arquivos de configuraÃ§Ã£o para o GitHub Actions:

```yaml
name: Node.js CI and DI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:10.8
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: school_test
          POSTGRES_PORT: 5432
        ports:
          - 5432:5432
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5

    strategy:
      matrix:
        node-version: [14.x]

    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm ci
      - run: npm run build --if-present
      - run: npm test
        env:
          DATABASE_HOST: localhost
          DATABASE_PORT: 5432
          DATABASE: school_test
          DATABASE_USERNAME: test
          DATABASE_PASSWORD: test
          # DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
      - uses: akhileshns/heroku-deploy@v3.12.12 # This is the action
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: 'app-name' #Must be unique in Heroku
          heroku_email: 'email-user-heroku@email.com'
```

O arquivo acima estÃ¡ configurado para executar os seguintes passos em sequÃªncia sempre que houver um `push` ou `pull request` no branch `main` do projeto:

1. Usa uma mÃ¡quina com Ubuntu;
1. Instala o Node.js 14.x;
1. Instala e configura uma instÃ¢ncia do banco de dados Postgres;
1. Gera a build o projeto;
1. Executa os testes;
1. Faz o deploy (implantaÃ§Ã£o) do projeto no Heroku.

OBS: Caso algum dos passos falhe o fluxo Ã© interrompido e os prÃ³ximos passos nÃ£o sÃ£o executados.

**_E aÃ­ quais dessas prÃ¡ticas vocÃª jÃ¡ usa? quais sÃ£o novas pra vocÃª?
Comente, sugira, corrija!!!_**

O cÃ³digo completo de todos os exemplos de boas prÃ¡ticas estÃ£o neste [repositÃ³rio do GitHub](https://github.com/jesielviana/nodejs-express-sequelize).

> E vocÃª gostou das dicas? Quais dessas boas prÃ¡ticas vocÃª jÃ¡ conhecia? Quais sÃ£o as boas prÃ¡ticas que vocÃª usa e recomanda? Deixe nos seus comentÃ¡rios ou no [Twitter](htts://twitter.com/jesielviana)

Veja meu curso de criaÃ§Ã£o de aplicaÃ§Ãµes Web, API com Node.js, Express, Jest e Postgres; e front-end integrado com API usando apenas Vanilla JS.

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/videoseries?list=PLAxN8g6Knm0camfON299B-vl31IYQhA8Q"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

**Demais ReferÃªncias Utilizadas**

- [10 Best Practices for Writing Node.js REST APIs | @RisingStack](https://blog.risingstack.com/10-best-practices-for-writing-node-js-rest-apis/)
- [Best practices for REST API design - Stack Overflow Blog](https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/)
- [Bulletproof node.js project architecture ğŸ›¡ï¸ - DEV Community](https://dev.to/santypk4/bulletproof-node-js-project-architecture-4epf)
- [GitHub - goldbergyoni/nodebestpractices: The Node.js best practices list (March 2021)](https://github.com/goldbergyoni/nodebestpractices#1-project-structure-practices)
