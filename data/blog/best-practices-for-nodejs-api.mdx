---
title: '9 boas pr√°ticas para constru√ß√£o de API Node.js'
date: 2020-04-15T15:32:14Z
tags: ['nodejs', 'api', 'arquitetura']
draft: false
summary: 'A utiliza√ß√£o de padr√µes e boas pr√°ticas no desenvolvimento de software evitam a duplicidade de c√≥digos, facilita a altera√ß√£o e evolu√ß√£o do software, aumenta a legibilidade do c√≥digo,  etc.'
images: ['/static/images/posts/banner-nodejs.png']
authors: ['default']
layout: PostSimple
---

### Introdu√ß√£o

[Node.js](https://nodejs.org/pt-br/) √© uma √≥tima ferramenta para constru√ß√£o APIs REST, sendo bastante utilizada no mundo todo, desde as grandes multinacionais at√© startups. Assim, como qualquer framework e plataformas de desenvolvimento de software existem um conjunto de recomenda√ß√µes e padr√µes a serem utilizados, ent√£o o objetivo deste artigo √© descrever um conjunto de **boas pr√°ticas para constru√ß√£o de APIs Node.js com Express**.

> A utiliza√ß√£o de padr√µes e boas pr√°ticas no desenvolvimento de software evitam a duplicidade de c√≥digos, facilita a altera√ß√£o e evolu√ß√£o do software, aumenta a legibilidade do c√≥digo, etc.

O conjunto de boas pr√°ticas que descrevo abaixo √© resultado da minha experi√™ncia em construir aplica√ß√µes Node.js, de v√°rios anos ensinando desenvolvimento Web, al√©m de uma extensa pesquisa e leitura de artigos, livros e c√≥digos de v√°rios projetos.

[o c√≥digo completo de todos os exemplos de boas pr√°ticas est√£o neste reposit√≥rio do GitHub](https://github.com/jesielviana/nodejs-express-sequelize)

### 1 - Arquitetura em 3 Camadas

Baseada no [Princ√≠pio da Separa√ß√£o de Conceitos](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html), organize a aplica√ß√£o em tr√™s camadas: API routes, Services e Models, conforme a figura abaixo.

![Arquitetura em camada Node.js](/static/images/posts/nodejs-layers.png)

- `API routes` - camada respons√°vel pela defini√ß√£o dos _endpoints_ da _API_ e tratamento das requisi√ß√µes e respostas da aplica√ß√£o.
- `Services` - camada respons√°vel pelas regras de neg√≥cios e por fazer a integra√ß√£o entre a camada de dados e a camada de API/Rotas.
- `Models` - camada respons√°vel pela modelagem e acesso aos dados da aplica√ß√£o.

### 2 - Estrutura do projeto

Em aplica√ß√µes Node.js geralmente s√£o utilizados dois tipos de estrutura√ß√£o de diret√≥rios:

- divis√£o por funcionalidade; e
- divis√£o por responsabilidade

Na divis√£o por funcionalidade todos os arquivos de uma determinadas funcionalidade s√£o agrupados em um √∫nico diret√≥rio, conforme o exemplo abaixo:

```shell:estrutura-projeto
src/
  ‚îú‚îÄ‚îÄ courses/
        ‚îú‚îÄ‚îÄ courses.service.js
        ‚îú‚îÄ‚îÄ course.model.js
        ‚îú‚îÄ‚îÄ courses.routes.js
  ‚îú‚îÄ‚îÄ students/
        ‚îú‚îÄ‚îÄ students.service.js
        ‚îú‚îÄ‚îÄ student.model.js
        ‚îú‚îÄ‚îÄ students.routes.js
  ‚îú‚îÄ‚îÄ app.js
```

J√° na organiza√ß√£o por responsabilidade os arquivos s√£o agrupados em diret√≥rios de acordo com a sua responsabilidade, conforme o exemplo abaixo:

```
src/
  ‚îú‚îÄ‚îÄ services/
        ‚îú‚îÄ‚îÄ courses.js
        ‚îú‚îÄ‚îÄ students.js
  ‚îú‚îÄ‚îÄ model/
        ‚îú‚îÄ‚îÄ course.js
        ‚îú‚îÄ‚îÄ student.js
  ‚îú‚îÄ‚îÄ routes/
        ‚îú‚îÄ‚îÄ index.js
        ‚îú‚îÄ‚îÄ courses.js
        ‚îú‚îÄ‚îÄ students.js
  ‚îú‚îÄ‚îÄ app.js
```

Entre essas duas abordagens eu recomendo a estrutura√ß√£o por responsabilidade. No entanto, n√£o existe uma op√ß√£o correta, fica a crit√©rio da equipe de cada projeto discutir e escolher aquela achar mais pertinente.

Baseado na organiza√ß√£o por responsabilidade, costumo organizar meus projetos da seguinte forma:

```
‚îú‚îÄ‚îÄ server.js         arquivo de inicializa√ß√£o da aplica√ß√£o/servidor
src/
  ‚îú‚îÄ‚îÄ app.js         arquivo de configura√ß√£o da aplica√ß√£o express
  ‚îú‚îÄ‚îÄ api/           camada de rotas da API
  ‚îú‚îÄ‚îÄ config/        arquivos de configura√ß√£o
  ‚îú‚îÄ‚îÄ services/      camada de servi√ßos
  ‚îú‚îÄ‚îÄ models/        camada dos modelos	de dados
test/
  ‚îú‚îÄ‚îÄ unit/          testes unit√°rios
  ‚îú‚îÄ‚îÄ integration/   testes de integra√ß√£o da API
‚îú‚îÄ‚îÄ package.json         arquivo de configura√ß√£o do projeto
‚îú‚îÄ‚îÄ ...         demais arquivos de configura√ß√µes (.gitignore, jest.config, .sequelizerc, etc)
```

**Obs:** recomendo a cria√ß√£o do arquivo `server.js` para inicializa√ß√£o do servidor http separado do arquivos de defini√ß√£o e configura√ß√£o do express, geralmente nomeado de `app.js` . Isso facilita demais a realiza√ß√£o dos testes de integra√ß√£o, pois permite testar a API usando somente o `app.js` , sem realizar chamadas de inicializa√ß√£o do servidor.

### 3 - Separe as regras de neg√≥cios do tratamento de requisi√ß√µes e respostas

√â comum encontrarmos v√°rias aplica√ß√µes que misturam o c√≥digo de tratamento de requisi√ß√µes e respostas com as regras de neg√≥cios da aplica√ß√£o. As vezes o c√≥digo de regras de neg√≥cios e acesso a dados ficam juntos dentro da camada de `routes` ou `controllers`, como no exemplo abaixo (**N√£o Fa√ßa Isso!**):

```js:src/routes/courses.js
// arquivo de rotas
router.post('/courses', async (req, res) => {
  try {
    const { name, ch } = req.body
        const existingCourse = await courseModel.findAll({
      where: {
        name: name
      }
    })
    if (existingCourse.length > 0) {
      throw new Error('Course already registered')
    }
    await courseModel.create({ name, ch })
    res.status(201).json({ message: 'Course created!' })
  } catch (err) {
    res.status(400).send(err.message)
  }
}
```

Em outros casos os objetos de requisi√ß√£o e resposta, geralmente nomeados de `req` e `res` s√£o passados da camada de `routes` para a camada de `services`, conforme podemos ver no exemplo abaixo (**Tamb√©m N√£o Fa√ßa Isso!**):

```js:src/routes/courses.js
// arquivo de tratamento de rotas na camada de routes
router.post('/courses', (req, res) => coursesService.create(req, res));
```

```js:src/services/courses.js
//  arquivo de servi√ßos
 create(req, res) {
  try {
    const { name, ch } = req.body
        const existingCourse = await courseModel.findAll({
      where: {
        name: name
      }
    })
    if (existingCourse.length > 0) {
      throw new Error('Course already registered')
    }
    await courseModel.create({ name, ch })
    res.status(201).json({ message: 'Course created!' })
  } catch (err) {
    res.status(400).send(err.message)
  }
}
```

Nos dois exemplos acima, o c√≥digo de tratamento de rotas, que inclui receber os dados do corpo da requisi√ß√£o, capturar par√¢metros de URL, validar dados da requisi√ß√£o, lidar com c√≥digos de status do HTTP e retornar as respostas da requisi√ß√£o est√£o misturados com o c√≥digo de valida√ß√£o de regras de neg√≥cios e c√≥digo de acesso e manipula√ß√£o dos dados.

Com isso a fun√ß√£o/classe assume muitas responsabilidades, ferindo as boas pr√°ticas de coes√£o e separa√ß√£o de conceitos. Isso impacta diretamente na escrita de testes unit√°rios dos `services` em que teremos que lidar com _mocks_ complexos para os objetos `req` e `res` do express.

Diante dessa situa√ß√£o, a minha recomenda√ß√£o √© isolar o c√≥digo de tratamento de requisi√ß√µes e respostas na camada de `routes` e o c√≥digo de regras de neg√≥cios e acesso a dados na camada de `services`. Segue um exemplo de boa pr√°tica baseado nos conceitos de separa√ß√£o das responsabilidades e coes√£o:

```js:src/routes/courses.js
//arquivo de tratamento de rotas na camada de API routes
router.post('/', async (req, res) => {
  try {
    const { name, ch } = req.body
    await courseService.create({ name, ch })
    res.status(201).json({ name, ch })
  } catch (err) {
    res.status(400).send(err.message)
  }
})
```

```js:src/services/courses.js
// arquivo com regras de neg√≥cios na camada de servi√ßos
async create (courseDTO) {
  try {
    await this.verifyIfCourseNameIsRegistered(courseDTO.name)
    await courseModel.create(courseDTO)
  } catch (err) {
    throw new Error(err.message)
  }
}

async verifyIfCourseNameIsRegistered (courseName) {
  const existingCourse = await courseModel.findAll({
    where: {
      name: courseName
    }
  })
  if (existingCourse.length > 0) {
    throw new Error('Course already registered')
  }
}
```

Com essa separa√ß√£o mantemos as fun√ß√µes e arquivos/classes coesas, com responsabilidades √∫nicas, al√©m disso torna a cria√ß√£o dos testes unit√°rios mais simples, sem a necessidade de _mock_ dos objetos de `req` e `res`.

Para todos os exemplos utilizados neste item foi utilizado um model do sequelize (listado abaixo), que representava o objeto `courseModel`.

```js:models/course.js
  const CourseModel = sequelize.define('Course', {
    name: {
      type: DataTypes.STRING,
      unique: true,
      allowNull: false,
      validate: {
        notEmpty: true
      }
    },
    ch: {
      type: DataTypes.INTEGER,
      allowNull: false,
      validate: {
        notEmpty: true
      }
    }
  })
```

> [o c√≥digo completo de todos os exemplos de boas pr√°ticas est√£o neste reposit√≥rio do GitHub](https://github.com/jesielviana/nodejs-express-sequelize)

Resumindo este item:

- Separe o c√≥digo dos `routes` do express da camada de `services`
- Tudo relacionado a url, c√≥digo de status, cabe√ßalhos e m√©todos do HTTP devem ser tratados na camada/arquivo de `routes`
- N√£o passe os objetos `req` e `res` para a camada/arquivo de `services`
- A camada de `services` deve lidar exclusiavamente com as regras e neg√≥cios e integra√ß√£o com os `models`.

### 4 - Use os m√©todos HTTP de forma sem√¢ntica e substantivo para identifica√ß√£o de rotas

Para cada tipo de opera√ß√£o que podemos realizar por meio de uma API h√° um m√©todo HTTP adequado, com valor sem√¢ntico. USE-OS! Para as quatro opera√ß√µes b√°sicas de um CRUD, criar, consultar, alterar e remover devemos utilizar os m√©todos POST, GET, PUT/PATCH e DELETE respectivamente, j√° que cada um desse m√©todos s√£o semanticamente correspondentes a cada uma dessas opera√ß√µes. Por exemplo:

- `POST /courses` para criar um novo curso,
- `GET /courses` para consultar todos os cursos,
- `GET /courses/:id` para consultar um curso espec√≠fico,
- `PATCH /courses/:id` or `PUT /courses/:id` para alterar um curso j√° cadastrado,
- `DELETE /courses/:id` para remover um curso j√° cadastrado.

> OBS: PUT e PATCH s√£o usados para altera√ß√£o de dados. PUT √© semanticamente indicado para altera√ß√£o da entidade completa, ou seja, sobrescrita de todos os dados da entidade/recurso a ser alterado. J√° o PATCH para uma atualiza√ß√£o parcial, quando se deseja sobrescrever um atribudo espec√≠fico da entidade/recurso
> [https://tools.ietf.org/html/rfc5789](PATCH) > [https://tools.ietf.org/html/rfc2616#section-9.6](PUT).

Como pr√°tica recomendada, suas rotas de API (**endpoints**) devem utilizar substantivos no plural como identificadores dos recursos, como no exemplo acima, usamos o identicador `courses` como rota (**endpoints**) para manipula√ß√£o de cursos.

### 5 - Use os c√≥digos de status do HTTP de forma correta

Olha s√≥ essa "pegadinha" relatada nesse tweet abaixo:

<blockquote class="twitter-tweet"><p lang="pt" dir="ltr">Submeto um formul√°rio que perdi um tempo preenchendo, ele d√° um erro. Vou olhar o request (l√≥gico), via xhr, ele d√° status 200. No json de retorno tem um atributo `{erro: true}`. ü§¶‚Äç‚ôÇÔ∏è<br/>A empresa √© do mercado financeiro, e √© grande.<br/>N√£o me surpreende.<br/>Somos amadores. <a href="https://t.co/7VLEspvThv">pic.twitter.com/7VLEspvThv</a></p>&mdash; Giovanni Bassi üáßüá∑ (@giovannibassi) <a href="https://twitter.com/giovannibassi/status/1362871241128960004?ref_src=twsrc%5Etfw">February 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

O relatado no tweet acima n√£o √© algo raro, uma vez ou outra nos deparamos com isso em APIs e p√°ginas Web. No entanto, √© algo que devemos evitar. Isso parece at√© uma pegadinha, retorna o status code 200, que indica sucesso na requisi√ß√£o, e no corpo da resposta vem um uma mensagem de erro ou uma flag (true ou false) indicando que ocorreu algum erro...resumindo: Parece sucesso, mas √© erro.

Para evitar confus√µes e m√°s pr√°ticas retornando c√≥digos de status do HTTP que n√£o condiz com a realidade da requisi√ß√£o, √© bom conhecermos os principais c√≥digos, seus significados e quando e como devemos us√°-los. Veja a lista abaixo com os principais c√≥digos de status do HTTP e seus significados:

- **2xx**, c√≥digos que indicam sucesso da requisi√ß√£o, os dois mais utilizados s√£o:
  - `200 Ok` - Indica sucesso na requisi√ß√£o (pra qualquer tipo de requisi√ß√£o).
  - `201 Ok` - Indica sucesso para requisi√ß√µes de cria√ß√£o de recurso (espec√≠fica para POST).
- **3xx**, c√≥digos que indicam que o recurso foi movido (pouco utilizado),
- **4xx**, c√≥digos que indicam erros causados pelo cliente
  - `400 Bad Request` ‚Äì indica que algum dado enviado na requisi√ß√£o est√° incorreto.
  - `401 Unauthorized` ‚Äì indica que o usu√°rio/cliente n√£o tem autoriza√ß√£o para acessar determinado recurso, geralmente √© provocado pela falta de autentica√ß√£o.
  - `403 Forbidden` ‚Äì indica que o usu√°rio √© conhecido (est√° autenticado), mas n√£o tem permiss√£o para acessar aquele recurso.
  - `404 Not Found` ‚Äì indica que o recurso solicitado n√£o existe.
- **5xx**, indica alguma erro inesperado no lado do servidor, √© recomendado tratar este tipo de erro para n√£o ser exibido diretamente para o usu√°rio/cliente.

### 6 - Crie testes de integra√ß√£o para todas as rotas de sua API

Teste automatizado criado pelos desenvolvedores √© algum essencial no desenvolvimento de software. Esses testes s√£o dividos em tr√™s catagorias: Teste de Unidade, Teste de Ingegra√ß√£o e Teste de Inteface (end-to-end).

Para o desenvolviemtno de APIs √© recomendado a constru√ß√£o de testes de unidade e testes de integra√ß√£o, sendo este o mais completo.

O teste de integra√ß√£o em APIs tem caracter√≠sticas do testes de caixa preta, que √© a forma de testar uma funcionalidade de um aplicativo sem o conhecimento de suas estruturas internas ou funcionamento. Portanto, na cria√ß√£o dos testes de integra√ß√£o o sistema/API √© testado como um todo sem a cria√ß√£o de mocks. Nenhum mock √© criado!

No ambiente Node.js com Express s√£o bastantes utilizados o Jest e Supertest para a cria√ß√£o e execu√ß√£o de testes de integra√ß√£o. O c√≥digo abaixo apresenta um exemplo de teste de integra√ß√£o para a cria√ß√£o de curso.

```js:test/api/curso.test.js
const request = require('supertest')
const config = require('../../../src/config')
const app = require('../../../src/app')
const { sequelize } = require('../../../src/models')

const API_COURSES = `${config.API_BASE}/courses`

const DEFAULT_COURSE = {
  name: 'Curso 1',
  ch: 1500
}

beforeAll(async () => {
  await sequelize.sync({ force: true }) // conecta com o banco de testes
  await request(app).post(API_COURSES).send(DEFAULT_COURSE) // insere um curso no banco
})

afterAll(async () => {
  await sequelize.close() // fecha a conex√£o com o banco
})

describe('Testando a rota de curso', () => {
  test('Deve adicionar um novo curso com sucesso!', async () => {
    const newCourse = {
      name: 'Curso 2',
      ch: 3020
    }
    const response = await request(app).post(API_COURSES).send(newCourse)
    expect(response.statusCode).toBe(201)
  })
})

```

No exemplo acima √© realizado um teste completo de cria√ß√£o de um novo curso, desde a requisi√ß√£o HTTP na rota de curso passando o dados do novo curso at√© a inser√ß√£o no banco de dados e verifica√ß√£o da resposta HTTP. Exemplo completo est√° neste [reposit√≥rio do GitHub](https://github.com/jesielviana/nodejs-express-sequelize).

### 7 - Cuide bem da seguran√ßa de sua API

Quando falamos de seguran√ßa na Web o uso de HTTPS (TLS/SSL) √© fundamental e obrigat√≥rio. USE SEMPRE HTTPS!

Quando for utilizar m√≥dulos/deped√™ncias do NPM verifique a origem, atualiza√ß√µes, poss√≠veis falhas de seguran√ßa, etc. Para isso, recomendo a utiliza√ß√£o do [Snyk Open Source Security Management](https://snyk.io/product/open-source-security-management/), uma ferramenta que conecta com seu reposit√≥rio do GitHub e verifica poss√©veis brechas de seguran√ßas de todas as depend√™ncias de sua aplica√ß√£o Node.js.

Em aplica√ß√µes com Express.js, use o [Helmet](https://helmetjs.github.io/). Helmet √© uma biblioteca para Express.js que agrega v√°rios middlewares, respons√°veis por setar alguns headers nas mensagens HTTP, tornando sua aplica√ß√£o mais segura.

### 8 - Crie arquivos de configura√ß√£o para cada ambiente

Crie arquivos de configura√ß√µes, com dados de banco de dados, endere√ßos de APIs externas e etc, para cada ambiente (development, test, production) e carregue suas informa√ß√µes de acordo com cada ambiente de forma automatizada. Segue um exemplo:

Arquivo index.js, que carrega as configura√ß√µes de acordo com o ambiente.

```js:config/index.js
const config = require(`./env/${process.env.NODE_ENV || 'development'}.js`)
module.exports = config
```

Arquivos de cada ambiente

```
src/
  ‚îú‚îÄ‚îÄ config/
      ‚îú‚îÄ‚îÄ development.js
      ‚îú‚îÄ‚îÄ test.js
      ‚îú‚îÄ‚îÄ production.js
```

Dentro de cada arquivo (development, test, production) s√£o colocadas as informa√ß√µes de configura√ß√£o espec√≠ficas daquele ambiente. Pode-se usar tamb√©m os arquivos `.env` para cada ambiente ao inv√©s de arquivos `js` como no exemplo acima.

### 9 - Utilize Integra√ß√£o e Entrega Cont√≠nua

A Integra√ß√£o Cont√≠nua - [Continuous Integration (CI)](https://aws.amazon.com/pt/devops/continuous-integration) √© uma pr√°tica de desenvolvimento de software em que os desenvolvedores, com frequ√™ncia, juntam suas altera√ß√µes de c√≥digo em um reposit√≥rio central e executam testes automatizados.

A Entrega Cont√≠nua - [Continuous Delivery (CD)](https://www.atlassian.com/br/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment) √© uma extens√£o da integra√ß√£o cont√≠nua, uma vez que implanta automaticamente todas as altera√ß√µes de c√≥digo em um ambiente de teste e / ou produ√ß√£o ap√≥s o est√°gio de constru√ß√£o.

√â importante destacar que para a utiliza√ß√£o de Integra√ß√£o e Entrega Cont√≠nua √© essencial que sua aplica√ß√£o use e abuse de testes automatizados, testes unit√°rios e principalmente testes de integra√ß√£o.

A configura√ß√£o e utiliza√ß√£o dos recursos de Integra√ß√£o e Entrega Cont√≠nua tem sido bastante simples em projetos armazenados no GitHub e Gitlab.
Segue um exemplo de arquivos de configura√ß√£o para o GitHub Actions:

```yaml
name: Node.js CI and DI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:10.8
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: school_test
          POSTGRES_PORT: 5432
        ports:
          - 5432:5432
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5

    strategy:
      matrix:
        node-version: [14.x]

    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}
      - run: npm ci
      - run: npm run build --if-present
      - run: npm test
        env:
          DATABASE_HOST: localhost
          DATABASE_PORT: 5432
          DATABASE: school_test
          DATABASE_USERNAME: test
          DATABASE_PASSWORD: test
          # DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
      - uses: akhileshns/heroku-deploy@v3.12.12 # This is the action
        with:
          heroku_api_key: ${{ secrets.HEROKU_API_KEY }}
          heroku_app_name: 'app-name' #Must be unique in Heroku
          heroku_email: 'email-user-heroku@email.com'
```

O arquivo acima est√° configurado para executar os seguintes passos em sequ√™ncia sempre que houver um `push` ou `pull request` no branch `main` do projeto:

1. Usa uma m√°quina com Ubuntu;
1. Instala o Node.js 14.x;
1. Instala e configura uma inst√¢ncia do banco de dados Postgres;
1. Gera a build o projeto;
1. Executa os testes;
1. Faz o deploy (implanta√ß√£o) do projeto no Heroku.

OBS: Caso algum dos passos falhe o fluxo √© interrompido e os pr√≥ximos passos n√£o s√£o executados.

**_E a√≠ quais dessas pr√°ticas voc√™ j√° usa? quais s√£o novas pra voc√™?
Comente, sugira, corrija!!!_**

O c√≥digo completo de todos os exemplos de boas pr√°ticas est√£o neste [reposit√≥rio do GitHub](https://github.com/jesielviana/nodejs-express-sequelize).

> E voc√™ gostou das dicas? Quais dessas boas pr√°ticas voc√™ j√° conhecia? Quais s√£o as boas pr√°ticas que voc√™ usa e recomanda? Deixe nos seus coment√°rios ou no [Twitter](htts://twitter.com/jesielviana)

Veja meu curso de cria√ß√£o de aplica√ß√µes Web, API com Node.js, Express, Jest e Postgres; e front-end integrado com API usando apenas Vanilla JS.

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/videoseries?list=PLAxN8g6Knm0camfON299B-vl31IYQhA8Q"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

**Demais Refer√™ncias Utilizadas**

- [10 Best Practices for Writing Node.js REST APIs | @RisingStack](https://blog.risingstack.com/10-best-practices-for-writing-node-js-rest-apis/)
- [Best practices for REST API design - Stack Overflow Blog](https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/)
- [Bulletproof node.js project architecture üõ°Ô∏è - DEV Community](https://dev.to/santypk4/bulletproof-node-js-project-architecture-4epf)
- [GitHub - goldbergyoni/nodebestpractices: The Node.js best practices list (March 2021)](https://github.com/goldbergyoni/nodebestpractices#1-project-structure-practices)
