---
title: '9 best practices for building Node.js API'
date: 2022-01-26
tags: ['nodejs', 'api', 'architecture']
draft: false
summary: 'The use of patterns and best practices in software development avoids duplication of code, facilitates software change and evolution, increases code readability, etc.'
images: ['/static/images/posts/banner-nodejs.png']
authors: ['default']
---

### Introduction

Node.js is a good tool for building REST APIs. It is one of the [most popular](https://insights.stackoverflow.com/survey/2021#technology-most-popular-technologies) techs among devs. **If you are a Node.js developer or are learning Node.js to build REST APIs, this post is for you**.

This post describes a set of best practices for building [Node.js](https://nodejs.org/pt-br/) APIs with the [Express](https://expressjs.com) framework.

> Applying patterns and best practices in coding is essential. Patterns increase code readability and ease software support.

The set of best practices described below is the result of my experience.
I have experience building Node.js applications and teaching web development. And a lot of readings of technical books and blog posts.

[The complete code of all good practice examples is in this GitHub repository](https://github.com/jesielviana/nodejs-express-sequelize)

### 1 - Layered architecture

Use the principle of [separation of concerns](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD447.html). Segregating an application code into three-tier architecture: API routes, Services, and Models.

![Node.js three-tier architecture](/static/images/posts/nodejs-layers.png)

- `API routes` - contains all the API routes of the app. It is responsible too for handling the HTTP requests and HTTP responses.
- `Services` - use this layer to put your business logic and for integrating the data layer and the API routes layer.
- `Models` - define the access to the data and database entities.

### 2 - Project structure

In Node.js applications, are generally used two types of directory structure:

- division by component
- division by technical role

In the division by component, the files are grouped by feature directory. See the example below:

```shell:projetc-structure
src/
  â”œâ”€â”€ courses/
        â”œâ”€â”€ courses.service.js
        â”œâ”€â”€ course.model.js
        â”œâ”€â”€ courses.routes.js
  â”œâ”€â”€ students/
        â”œâ”€â”€ students.service.js
        â”œâ”€â”€ student.model.js
        â”œâ”€â”€ students.routes.js
  â”œâ”€â”€ app.js
```

Structuring by technical roles, the files are grouped in the folders by layers, according to your responsibility. As you can see in the example below:

```shell:projetc-structure
src/
  â”œâ”€â”€ services/
        â”œâ”€â”€ courses.js
        â”œâ”€â”€ students.js
  â”œâ”€â”€ model/
        â”œâ”€â”€ course.js
        â”œâ”€â”€ student.js
  â”œâ”€â”€ routes/
        â”œâ”€â”€ index.js
        â”œâ”€â”€ courses.js
        â”œâ”€â”€ students.js
  â”œâ”€â”€ app.js
```

Between these two approaches, **I recommend structuring by technical role layer**. Yet, there is not the correct option. It is up to each project team to discuss and choose a default structure.

Based on structured by technical role layer, I organize my projects as follows:

```shell:projetc-structure
â”œâ”€â”€ server.js        the entry point for starting the server (network configurations)
src/
  â”œâ”€â”€ app.js         Express(http-server) config
  â”œâ”€â”€ api/           Express route handlers for all the endpoints of the app
  â”œâ”€â”€ config/        environment configurations
  â”œâ”€â”€ services/      service layer with the business logic
  â”œâ”€â”€ models/        model layer with database entities
test/
  â”œâ”€â”€ unit/          all the unit tests of the app
  â”œâ”€â”€ integration/   all the integration tests of the app
â”œâ”€â”€ package.json     main project configuration file
â”œâ”€â”€ ...              others config files (.gitignore, jest.config, .sequelizerc, etc)
```

I recommend separating Express definitions from HTTP network configuration. I usually named `app` for Express definition and `server` for HTTP network configs and server startup (see example above).
The `server` file with network configurations (port, protocol, etc) and startup. And the `app` file with the express API configuration (routes, JSON, and middleware).
This allows testing the API in-process in an isolated test environment. It guarantees a better separation of concerns and a cleaner code.

### 3 - Separate business logic from the router controllers

Some applications mix the APIs routes handling code with the application's business rules.

Sometimes the business rules and data access code are put in the API routes layer. As in the example below (Don't do this!):

```js:src/routes/courses.js
// arquivo de rotas
router.post('/courses', async (req, res) => {
  try {
    const { name, ch } = req.body
        const existingCourse = await courseModel.findAll({
      where: {
        name: name
      }
    })
    if (existingCourse.length > 0) {
      throw new Error('Course already registered')
    }
    await courseModel.create({ name, ch })
    res.status(201).json({ message: 'Course created!' })
  } catch (err) {
    res.status(400).send(err.message)
  }
}
```

In other cases, the APIs routes handling (HTTP request and HTTP response objects) are passed from the API routes layer to the services layer. As we can see in the example below (Don't do this too!).

```js:src/routes/courses.js
// arquivo de tratamento de rotas na camada de routes
router.post('/courses', (req, res) => coursesService.create(req, res));
```

```js:src/services/courses.js
//  arquivo de serviÃ§os
 create(req, res) {
  try {
    const { name, ch } = req.body
        const existingCourse = await courseModel.findAll({
      where: {
        name: name
      }
    })
    if (existingCourse.length > 0) {
      throw new Error('Course already registered')
    }
    await courseModel.create({ name, ch })
    res.status(201).json({ message: 'Course created!' })
  } catch (err) {
    res.status(400).send(err.message)
  }
}
```

In the two examples above, the APIs routes handling code is mixed with the business rules.

APIs routes are responsible for handling all HTTP requests and responses (validate request body data, URL parameters, sending the response with content and status code, etc). And the business rules perform requirements validation and data manipulation.

As a result, the function/class assumes many responsibilities, violating good practices of cohesion and separation of concepts. This impacts the code readability and maintainability. And makes it harder to write unit tests. (eg. dealing with complex mocks for express req and res objects).

Given this situation, you can isolate the code for handling APIs routes in the routes layer. And put the code for business rules and data access in the services layer.

The following is an example of good practice based on the concepts of separation of responsibilities and cohesion. See below:

```js:src/routes/courses.js
// handling HTTP requests and responses on the API routes layer
router.post('/', async (req, res) => {
  try {
    const { name, ch } = req.body
    await courseService.create({ name, ch })
    res.status(201).json({ name, ch })
  } catch (err) {
    res.status(400).send(err.message)
  }
})
```

```js:src/services/courses.js
// business logic and data manipulation on the service layer
async create (courseDTO) {
  try {
    await this.verifyIfCourseNameIsRegistered(courseDTO.name)
    await courseModel.create(courseDTO)
  } catch (err) {
    throw new Error(err.message)
  }
}

async verifyIfCourseNameIsRegistered (courseName) {
  const existingCourse = await courseModel.findAll({
    where: {
      name: courseName
    }
  })
  if (existingCourse.length > 0) {
    throw new Error('Course already registered')
  }
}
```

With this separation, you keep the code cohesive and more readable. Also, makes it simpler to create unit tests per layer.

For all the examples used in this item, I used a Sequelize model. This model represents the course entity for the Postgres database.

```js:models/course.js
  const CourseModel = sequelize.define('Course', {
    name: {
      type: DataTypes.STRING,
      unique: true,
      allowNull: false,
      validate: {
        notEmpty: true
      }
    },
    ch: {
      type: DataTypes.INTEGER,
      allowNull: false,
      validate: {
        notEmpty: true
      }
    }
  })
```

Summarizing this item:

- Separate the API routes code from the services layer;
- The API routes layer must handle everything related to HTTP requests: URL, status code, headers, and methods;
- Do not pass `req` and `res` objects to the services layer;
- The services layer must handle only business rules and integration with models.

## 4 - Identification of resources and operations

<span role="img" aria-label="roadwork sign">
  Under Construction... ðŸš§
</span>
